フォルダあり
→dotnet new console --language F#
(追加したいのあったらdotnet add package パッケージ名)
//実行→dotnet run

フォルダなし
→ファイル名.fsxを作ってカキコ
(追加したいのあったら#r "nuget: パッケージ名")
//実行→dotnet fsi ファイル名



F# いろいろ

[<EntryPoint>]
→プログラムの開始を宣言         //いらないときもある

let mutable 変数名:データ型=値
→変更できる変数の宣言

let 変数名 =値
→定数（変更できない値）の宣言

let 変数名:データ型=データ型 式;;
→型変換

変数名<-値
→値の代入

let 配列名:データ型[]=Array.zeroCreate 数字
→数字個の配列を作成（全て０）
※2次元配列の作成->let 配列名:データ型[,]=Array2D.zeroCreate 縦 横


printfn "書式指定文字列" 引数１ 引数２...
printfn $"書式指定文字列{引数}"
Console.WriteLine("メッセージ") //open Systemが必要
→標準出力

let 変数=Console.ReadLine()|>データ型 //open Systemが必要
→標準入力

*演算子
+ 加算
-  減算
*  乗算
/  除算
% 剰余
** べき乗

*ブール演算
||      OR 
&&   AND

*条件分岐 if~elif~else*
if 条件式1 then
        条件式1が成り立つときの処理...

elif 条件式2 then
        条件式2が成り立つときの処理...

else
        条件がすべて成り立たないときの処理...

*条件分岐 match~with*
match 変数 with
        |定数1->
                処理1;
        |定数2->
                処理2;
        |
        |_->どれも当てはまらない時の処理;;      //Cのswitch文でいう"default"


*ループ for~to~do*
for カウンタに使う変数=初期値 to 終わるときの値 do  //down toにするとカウントダウン
        処理...
        

*ループ for~in~do*
for カウンタに使う変数 in 範囲 do  	//範囲はseq{}や配列が使える
        処理...
        



*ループ while~do*
while 条件式 do //条件式が成り立っていたら処理を実行  (条件式をtrueにすると無限ループ)
        処理...


*サブルーチン*
定義 let 関数名(引数に対応する変数:変数のデータ型):戻り値のデータ型=  //配列なんかにも使えるよ!
        処理....

        戻り値の変数

        呼び出し let 変数=関数名 引数

引数なし let 関数名()=
        処理....

        戻り値の変数

呼び出し let 変数=関数名       #<-なんでもおk

*レコード*
定義 type レコードの形={
    要素A:データ型１
    要素B:データ型２....
}
作成 let レコード名:レコードの形={
        要素A=値１
        要素B=値２...
}


シーケンス(配列の代わりに使う)
let シーケンス名=seq{値}

seq{1..5} ->1,2,3,4,5となる
seq{0..10..100} ->10,20,30...と10の倍数となる
seq{式...} ->関数式を適用したシーケンス

yield!を使うと別のシーケンスに含められる
seq {
 for _ in 1..10 do
 yield! seq { 1; 2; 3; 4; 5}
}->10回1,2,3,4,5を繰り返す

*例外処理
 try
  処理..
 with
  |エラーメッセージ->エラー時の処理...
 //処理してエラーが出たら「エラー時の処理」を実行する

 try
  処理...
 finally
  追加の処理...
 //処理をしてエラーの有無関係なく追加処理を行う



*クラスについて
クラスは先に行う処理を定義＆構造化してそれを呼び出す形でプログラムが進行する

*クラスの定義*
定義 type クラス名(引数:データ型,...)as ここを示す名前=        #引数がなければ()でおk
        #inherit 親クラス名
        do
                処理...         #doの後の処理はクラスが定義される前に実行される(とりあえずdo処理で良いかも？)
        #処理...
        #let 宣言...
        #ここを示す名前.メソッド名()

        member ここを示す名前.関数メソッド名()=
                変数名:データ型
                処理... #doとかいらんよ
        member ここを示す名前.変数メソッド名:データ型=値

呼び出し 
let 変数=クラス名(引数)	 #引数がなければ()でおk
変数.クラスのメソッド名(引数) #クラスに対応しているメンバーを呼び出す
(初回はnew クラス名(引数)じゃないとダメっぽい)


*クラスの継承
親クラスを指定したい場合はinheritを使用する
inherit 親クラス(引数)


*メンバー(メソッド)について
クラス内に複数の処理を定義する
(指名して呼び出すこともできる!!)



*オーバーロードについて
同じ名前のメンバーで違う変数を使って処理などが行える

定義 member ここを示す名前.メソッドA(引数1,引数2)=
        A処理...

meber ここを示す名前.メソッドB(引数一,引数二)=
        B処理...


呼び出し
ここを示す名前.メソッド(引数)   #()の中に引数をいれてね！！



*オーバーライドについて
親クラスのメソッドの内容を書き換えて処理できる

定義 type 親クラス() as ここを示す名前=
    member ここを示す名前.メソッド() =
        処理...

type 子クラス() =
    inherit 親クラス()
    override ここを示す名前.親クラスのメソッド() =
        処理....



*抽象クラスについて
オーバーライドや継承でのみ使えるメソッド
共通の機能や振る舞いなんかを定義する
(default~でメソッドのデフォルトを設定できる)
#継承クラスじゃないと使えないよ！！

定義
[<AbstractClass>]
type 抽象クラス名(引数)=
　//普通の抽象クラス
　abstract member メソッド1:引数のデータ型->戻り値のデータ型

　//初期設定のある抽象クラス
　abstract member メソッド2:引数のデータ型->戻り値のデータ型
　default this.メソッド2(引数)=
　　処理....


type 継承(実体)クラス名(引数)=
　inherit 抽象クラス名(引数)

　override this.メソッド(引数)=
　　処理...

 #戻り値が抽象メンバーのデータ型と一致するように!!






*ラムダ式(匿名関数)
一時的な定義済み関数...みたいな

定義 (fun 引数->式) 引数の値



*関数合成について
関数の引数・戻り値が別の関数だったりするもの
例:y=f(x)の関数でx=g(x)->y=f(g(x))      #(g(x)の戻り値をf(x)にあてはめる)

定義 
関数1=処理1...
関数2=処理2...
合成関数=関数1>>関数2   #1->2の順で処理される

呼び出し 変数=合成関数 引数


*パイプライン関数
一時的な関数合成(ラムダ式の関数合成？)
変数=関数1の引数 |>関数1 追加の引数 |>関数2 |>関数3...


*高階関数
引数・戻り値として関数を渡すこと

定義 let 高階関数 引関数1 引関数2...=
        引関数 (その関数に対応した引数)         #3こ以上は f ( (f x))みたく()増やす

let引関数=
        処理...

呼び出し 変数=高階関数 引関数 引数の関数に対応した引数




*非同期処理

*遅延式(計算はしない)
        変数=lazy(式)

        *実行
        変数.Force()


























